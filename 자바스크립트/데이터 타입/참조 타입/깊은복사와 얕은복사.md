# 목차
- 얕은 복사란?
- 깊은 복사란?
- 스프레드 연산자
- 달라져 버린 주소값
- 스프레드 연산자의 얕은 복사

## 얕은 복사란?
얕은 복사는 복사할 대상의 `주소 값`을 복사 합니다. 주소 값을 복사해 오기 때문에 참조 했던 값의 변화가 오면 원본에도 영향을 끼치게 됩니다.
```js
const obj = {
    a :10,
    b: 'abc'
}
const obj2 = obj;

console.log(obj===obj2) /// true
```
그래서 비교 연산자를 사용하여 비교 해도 true 값이 나오게 됩니다.


## 깊은 복사란?
깊은 복사는 복사할 대상의 `실제 값`만 복사 합니다.

얕은 복사와는 다르게 깊은 복사는 값만 가져오기 때문에 깊은 복사의 경우 값을 변화 시켜도 원래 참조 했던 값의 영향을 줄 수 없습니다.

깊은 복사를 하려면 스프레드 연산자를 사용해야 합니다.

## 스프레드 연산자
영문명으로 spread 라고 하며 기존에 배열이나 객체의 전체 혹은 일부를 다른 변수로 복사가 가능합니다.
스프레드 연산자를 사용하기 위해선 (...) 을 사용하면 됩니다. 예시를 보여드리겠습니다.
```js
const arr = [1,2,3,4,5,6,7]
const brr = [8,9]

const crr = [...arr, ...brr] // [1,2,3,4,5,6,7,8,9]
```
이렇게 값을 쉽게 합치는 것도 가능하고,
```js
const arr = [1,2,3,4,5,6,7]
const brr = [...arr]

brr.push(8,9)

console.log(brr) // [1,2,3,4,5,6,7,8,9]
console.log(arr) // [1,2,3,4,5,6,7]
```
이렇게 arr 의 값엔 영향을 주지 않고 배열brr 의 값을 추가 할 수도 있습니다.

값에 영향을 주지 않는 이유는 스프레드 연산자를 사용하면서 새로운 배열을 만들기 때문입니다.

## 달라져 버린 주소값
스프레드 연산자를 사용하려면 스프레드 연산자를 덮을 새로운 배열이나 객체가 필요합니다. 이렇게 되는 과정에서 새로운 참조 타입이 생성 됐기 때문에 주소 값이 바뀌게 됩니다.
```js
const obj = {
    a :10,
    b: 'abc'
}
const obj2 = {...obj}

console.log(obj===obj2) //false
```
그래서 스프레드 연산자로 복사본을 만들때 새로운 객체나 배열을 만들게 되고 주소 값도 새로 생겨 비교 연산자로 둘을 비교 했을 때 false 가 반환됩니다.

```js
const obj = [1,2,3,4,5]

const obj2 = [[...obj],[...obj]]

console.log(obj2[0]===obj[1]) // false
```
그래서 이 코드가 왜 false 가 반환되는지 설명이 됩니다. obj배열을 스프레드 연산자로 만들면서 새로운 배열을 생성했기 때문에 주소 값이 서로 달라지기 때문입니다.

## 스프레드 연산자의 얕은 복사
허나 스프레드 연산자로 복사를 했어도 객체안에 객체, 배열안에 배열을 복사 하는 이 경우 문제가 발생하게 됩니다.
```js
const obj = {
    a : 10,
    b : {
        a : 30,
        b : 12
    }
}
const obj2 = {...obj}
obj2.b.a = 100;
console.log(obj2.b.a) // 100
console.log(obj.b.a) // 100
```
이렇게 객체와 같은 참조형 변수들은 변수에 할당하게 되면 주소값이 할당 되기 떄문에 해당 객체의 값을 변경하게 되면 참조하고 있던 같은 주소가 함께 변경 되어 버립니다.
